<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"></meta><title>QueryRecord</title><link rel="stylesheet" href="../../../../../css/component-usage.css" type="text/css"></link></head><script type="text/javascript">window.onload = function(){if(self==top) { document.getElementById('nameHeader').style.display = "inherit"; } }</script><body><h1 id="nameHeader" style="display: none;">QueryRecord</h1><h2>Description: </h2><p>Evaluates one or more SQL queries against the contents of a FlowFile. The result of the SQL query then becomes the content of the output FlowFile. This can be used, for example, for field-specific filtering, transformation, and row-level filtering. Columns can be renamed, simple calculations and aggregations performed, etc. The Processor is configured with a Record Reader Controller Service and a Record Writer service so as to allow flexibility in incoming and outgoing data formats. The Processor must be configured with at least one user-defined property. The name of the Property is the Relationship to route data to, and the value of the Property is a SQL SELECT statement that is used to specify how input data should be transformed/filtered. The SQL statement must be valid ANSI SQL and is powered by Apache Calcite. If the transformation fails, the original FlowFile is routed to the 'failure' relationship. Otherwise, the data selected will be routed to the associated relationship. If the Record Writer chooses to inherit the schema from the Record, it is important to note that the schema that is inherited will be from the ResultSet, rather than the input Record. This allows a single instance of the QueryRecord processor to have multiple queries, each of which returns a different set of columns and aggregations. As a result, though, the schema that is derived will have no schema name, so it is important that the configured Record Writer not attempt to write the Schema Name as an attribute if inheriting the Schema from the Record. See the Processor Usage documentation for more information.</p><p><a href="additionalDetails.html">Additional Details...</a></p><h3>Tags: </h3><p>sql, query, calcite, route, record, transform, select, update, modify, etl, filter, record, csv, json, logs, text, avro, aggregate</p><h3>Properties: </h3><p>In the list below, the names of required properties appear in <strong>bold</strong>. Any other properties (not in bold) are considered optional. The table also indicates any default values, and whether a property supports the <a href="../../../../../html/expression-language-guide.html">NiFi Expression Language</a>.</p><table id="properties"><tr><th>Display Name</th><th>API Name</th><th>Default Value</th><th>Allowable Values</th><th>Description</th></tr><tr><td id="name"><strong>Record Reader</strong></td><td>record-reader</td><td></td><td id="allowable-values"><strong>Controller Service API: </strong><br/>RecordReaderFactory<br/><strong>Implementations: </strong><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.json.JsonPathReader/index.html">JsonPathReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.syslog.Syslog5424Reader/index.html">Syslog5424Reader</a><br/><a href="../../../nifi-scripting-nar/2.0.0-M4/org.apache.nifi.record.script.ScriptedReader/index.html">ScriptedReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.cef.CEFReader/index.html">CEFReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.avro.AvroReader/index.html">AvroReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.csv.CSVReader/index.html">CSVReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.json.JsonTreeReader/index.html">JsonTreeReader</a><br/><a href="../../../nifi-protobuf-services-nar/2.0.0-M4/org.apache.nifi.services.protobuf.ProtobufReader/index.html">ProtobufReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.windowsevent.WindowsEventLogReader/index.html">WindowsEventLogReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.syslog.SyslogReader/index.html">SyslogReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.xml.XMLReader/index.html">XMLReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.lookup.ReaderLookup/index.html">ReaderLookup</a><br/><a href="../../../nifi-poi-nar/2.0.0-M4/org.apache.nifi.excel.ExcelReader/index.html">ExcelReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.yaml.YamlTreeReader/index.html">YamlTreeReader</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.grok.GrokReader/index.html">GrokReader</a></td><td id="description">Specifies the Controller Service to use for parsing incoming data and determining the data's schema</td></tr><tr><td id="name"><strong>Record Writer</strong></td><td>record-writer</td><td></td><td id="allowable-values"><strong>Controller Service API: </strong><br/>RecordSetWriterFactory<br/><strong>Implementations: </strong><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.lookup.RecordSetWriterLookup/index.html">RecordSetWriterLookup</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.avro.AvroRecordSetWriter/index.html">AvroRecordSetWriter</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.text.FreeFormTextRecordSetWriter/index.html">FreeFormTextRecordSetWriter</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.json.JsonRecordSetWriter/index.html">JsonRecordSetWriter</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.xml.XMLRecordSetWriter/index.html">XMLRecordSetWriter</a><br/><a href="../../../nifi-scripting-nar/2.0.0-M4/org.apache.nifi.record.script.ScriptedRecordSetWriter/index.html">ScriptedRecordSetWriter</a><br/><a href="../../../nifi-record-serialization-services-nar/2.0.0-M4/org.apache.nifi.csv.CSVRecordSetWriter/index.html">CSVRecordSetWriter</a></td><td id="description">Specifies the Controller Service to use for writing results to a FlowFile</td></tr><tr><td id="name"><strong>Include Zero Record FlowFiles</strong></td><td>include-zero-record-flowfiles</td><td id="default-value">true</td><td id="allowable-values"><ul><li>true</li><li>false</li></ul></td><td id="description">When running the SQL statement against an incoming FlowFile, if the result has no data, this property specifies whether or not a FlowFile will be sent to the corresponding relationship</td></tr><tr><td id="name"><strong>Cache Schema</strong></td><td>cache-schema</td><td id="default-value">true</td><td id="allowable-values"><ul><li>true</li><li>false</li></ul></td><td id="description">This property is no longer used. It remains solely for backward compatibility in order to avoid making existing Processors invalid upon upgrade. This property will be removed in future versions. Now, instead of forcing the user to understand the semantics of schema caching, the Processor caches up to 25 schemas and automatically rolls off the old schemas. This provides the same performance when caching was enabled previously and in some cases very significant performance improvements if caching was previously disabled.</td></tr><tr><td id="name"><strong>Default Decimal Precision</strong></td><td>dbf-default-precision</td><td id="default-value">10</td><td id="allowable-values"></td><td id="description">When a DECIMAL/NUMBER value is written as a 'decimal' Avro logical type, a specific 'precision' denoting number of available digits is required. Generally, precision is defined by column data type definition or database engines default. However undefined precision (0) can be returned from some database engines. 'Default Decimal Precision' is used when writing those undefined precision numbers.<br/><strong>Supports Expression Language: true (will be evaluated using flow file attributes and Environment variables)</strong></td></tr><tr><td id="name"><strong>Default Decimal Scale</strong></td><td>dbf-default-scale</td><td id="default-value">0</td><td id="allowable-values"></td><td id="description">When a DECIMAL/NUMBER value is written as a 'decimal' Avro logical type, a specific 'scale' denoting number of available decimal digits is required. Generally, scale is defined by column data type definition or database engines default. However when undefined precision (0) is returned, scale can also be uncertain with some database engines. 'Default Decimal Scale' is used when writing those undefined numbers. If a value has more decimals than specified scale, then the value will be rounded-up, e.g. 1.53 becomes 2 with scale 0, and 1.5 with scale 1.<br/><strong>Supports Expression Language: true (will be evaluated using flow file attributes and Environment variables)</strong></td></tr></table><h3>Dynamic Properties: </h3><p>Supports Sensitive Dynamic Properties: <strong>No</strong></p><p>Dynamic Properties allow the user to specify both the name and value of a property.<table id="dynamic-properties"><tr><th>Name</th><th>Value</th><th>Description</th></tr><tr><td id="name">The name of the relationship to route data to</td><td id="value">A SQL SELECT statement that is used to determine what data should be routed to this relationship.</td><td>Each user-defined property specifies a SQL SELECT statement to run over the data, with the data that is selected being routed to the relationship whose name is the property name<br/><strong>Supports Expression Language: true (will be evaluated using flow file attributes and Environment variables)</strong></td></tr></table></p><h3>Relationships: </h3><table id="relationships"><tr><th>Name</th><th>Description</th></tr><tr><td>failure</td><td>If a FlowFile fails processing for any reason (for example, the SQL statement contains columns not present in input data), the original FlowFile it will be routed to this relationship</td></tr><tr><td>original</td><td>The original FlowFile is routed to this relationship</td></tr></table><h3>Dynamic Relationships: </h3><p>A Dynamic Relationship may be created based on how the user configures the Processor.<table id="dynamic-relationships"><tr><th>Name</th><th>Description</th></tr><tr><td>&lt;Property Name&gt;</td><td>Each user-defined property defines a new Relationship for this Processor.</td></tr></table></p><h3>Reads Attributes: </h3>None specified.<h3>Writes Attributes: </h3><table id="writes-attributes"><tr><th>Name</th><th>Description</th></tr><tr><td>mime.type</td><td>Sets the mime.type attribute to the MIME Type specified by the Record Writer</td></tr><tr><td>record.count</td><td>The number of records selected by the query</td></tr><tr><td>QueryRecord.Route</td><td>The relation to which the FlowFile was routed</td></tr></table><h3>State management: </h3>This component does not store state.<h3>Restricted: </h3>This component is not restricted.<h3>Input requirement: </h3>This component requires an incoming relationship.<h2>Example Use Cases:</h2><h3>Use Case:</h3><p>Filter out records based on the values of the records' fields</p><h4>Keywords:</h4>filter out, remove, drop, strip out, record field, sql<h4>Configuration:</h4><p>"Record Reader" should be set to a Record Reader that is appropriate for your data.</p><p>"Record Writer" should be set to a Record Writer that writes out data in the desired format.</p><p></p><p>One additional property should be added.</p><p>The name of the property should be a short description of the data to keep.</p><p>Its value is a SQL statement that selects all columns from a table named <code>FLOW_FILE</code> for relevant rows.</p><p>The WHERE clause selects the data to keep. I.e., it is the exact opposite of what we want to remove.</p><p>It is recommended to always quote column names using double-quotes in order to avoid conflicts with SQL keywords.</p><p>For example, to remove records where either the name is George OR the age is less than 18, we would add a   property named "adults not george" with a value that selects records where the name is not George AND the age is greater than or equal to 18.   So the value would be <code>SELECT * FROM FLOWFILE WHERE "name" &lt;&gt; 'George' AND "age" &gt;= 18</code></p><p></p><p>Adding this property now gives us a new Relationship whose name is the same as the property name. So, the "adults not george" Relationship should be connected to the next Processor in our flow.</p><br></br><h3>Use Case:</h3><p>Keep only specific records</p><h4>Keywords:</h4>keep, filter, retain, select, include, record, sql<h4>Configuration:</h4><p>"Record Reader" should be set to a Record Reader that is appropriate for your data.</p><p>"Record Writer" should be set to a Record Writer that writes out data in the desired format.</p><p></p><p>One additional property should be added.</p><p>The name of the property should be a short description of the data to keep.</p><p>Its value is a SQL statement that selects all columns from a table named <code>FLOW_FILE</code> for relevant rows.</p><p>The WHERE clause selects the data to keep.</p><p>It is recommended to always quote column names using double-quotes in order to avoid conflicts with SQL keywords.</p><p>For example, to keep only records where the person is an adult (aged 18 or older), add a property named "adults"   with a value that is a SQL statement that selects records where the age is at least 18.   So the value would be <code>SELECT * FROM FLOWFILE WHERE "age" &gt;= 18</code></p><p></p><p>Adding this property now gives us a new Relationship whose name is the same as the property name. So, the "adults" Relationship should be connected to the next Processor in our flow.</p><br></br><h3>Use Case:</h3><p>Keep only specific fields in a a Record, where the names of the fields to keep are known</p><h4>Keywords:</h4>keep, filter, retain, select, include, record, fields, sql<h4>Configuration:</h4><p>"Record Reader" should be set to a Record Reader that is appropriate for your data.</p><p>"Record Writer" should be set to a Record Writer that writes out data in the desired format.</p><p></p><p>One additional property should be added.</p><p>The name of the property should be a short description of the data to keep, such as <code>relevant fields</code>.</p><p>Its value is a SQL statement that selects the desired columns from a table named <code>FLOW_FILE</code> for relevant rows.</p><p>There is no WHERE clause.</p><p>It is recommended to always quote column names using double-quotes in order to avoid conflicts with SQL keywords.</p><p>For example, to keep only the <code>name</code>, <code>age</code>, and <code>address</code> fields, add a property named <code>relevant fields</code>   with a value of <code>SELECT "name", "age", "address" FROM FLOWFILE</code></p><p></p><p>Adding this property now gives us a new Relationship whose name is the same as the property name. So, the <code>relevant fields</code> Relationship should be connected to the next Processor in our flow.</p><br></br><h3>Use Case:</h3><p>Route record-oriented data for processing based on its contents</p><h4>Keywords:</h4>record, route, conditional processing, field<h4>Configuration:</h4><p>"Record Reader" should be set to a Record Reader that is appropriate for your data.</p><p>"Record Writer" should be set to a Record Writer that writes out data in the desired format.</p><p></p><p>For each route that you want to create, add a new property.</p><p>The name of the property should be a short description of the data that should be selected for the route.</p><p>Its value is a SQL statement that selects all columns from a table named <code>FLOW_FILE</code>. The WHERE clause selects the data that should be included in the route.</p><p>It is recommended to always quote column names using double-quotes in order to avoid conflicts with SQL keywords.</p><p></p><p>A new outbound relationship is created for each property that is added. The name of the relationship is the same as the property name.</p><p></p><p>For example, to route data based on whether or not it is a large transaction, we would add two properties:</p><p><code>small transaction</code> would have a value such as <code>SELECT * FROM FLOWFILE WHERE transactionTotal &lt; 100</code></p><p><code>large transaction</code> would have a value of <code>SELECT * FROM FLOWFILE WHERE transactionTotal &gt;= 100</code></p><br></br><h3>System Resource Considerations:</h3>None specified.</body></html>